<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Wednesday, April 06, 2016, 7:54 AM -->
<!-- MuClient version 4.94 -->

<!-- Plugin "Galaban_DoThen" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Galaban_DoThen"
   author="Galaban"
   id="a0c2aaa6c93d97f516483553"
   language="Lua"
   purpose="Creates a &quot;do&quot; and &quot;then&quot; command for repeat commands"
   date_written="2016-04-06 07:53:57"
   requires="4.65"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   match="You are done *."
   send_to="12"
   sequence="100"
   script="actionCompleted"
  >
  </trigger>

</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   script="setThenCommand"
   match="then *"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   script="clearThenCommand"
   match="then"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   script="setDoCommand"
   match="^do (\d+) (.+)$"
   regexp="y"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   script="setDoDelay"
   match="do delay *"
   regexp="n"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   script="clearDoCommand"
   match="do"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

  <alias
   script="clearAll"
   match="stop"
   enabled="y"
   send_to="12"
   sequence="100"
  >
  </alias>

</aliases>

<!--  Script  -->

<script>
<![CDATA[

-------------------------------
--  Globals
--
DEFAULT_DELAY = 0.5
DO_CALLER = 1
THEN_CALLER = 2
do_command = ""
do_count = -1
then_command = ""
config_delay = DEFAULT_DELAY

-- Global functions (for other plugins/scripts to call)
function getRepeatCount()
    return do_count
end

function getRepeatCommand()
    return do_command
end


-------------------------------
--  Utility Functions
--
function getRandDelay(delay)
    local randDelay = delay + (math.random() * delay)
    return randDelay 
end

function stripCommand(inVal)
    return string.gsub(inVal,'\"',"")
end

-------------------------------
--  plugin events
--
function OnPluginInstall()
    config_delay = tonumber(GetVariable("dodelay")) or DEFAULT_DELAY
end

function OnPluginCommandEntered(sText)
    -- If command stacking is not enabled, just let the alias handle it.
    local dostack = GetOption("enable_command_stack")
    if (dostack == 0) then
        return sText
    end

    local thenStart, thenCommand = string.find(sText,"then .")

    -- TODO:  Currently, this does not check for ;;then escape characters.
    -- So, typing in "say Good;;then again..."  That will fail
    -- HOWEVER, this is actually a typo, since there should be a space between the semicolon and "then".
    -- Still, to fix this the entire loop needs changed to a byte-by-byte check to look for semi-colons
    -- ... a true parser.  Doing that in Lua, though, would not be exactly efficient.

    if (thenStart ~= nil) then

        local stackchar = GetAlphaOption("command_stack_character")

        local thenDoStr = sText:sub(thenCommand)

        if (thenStart ~= 1) then
            -- Must be in a sentence or something.
            if (sText:sub(thenStart-1,thenStart-1) ~= stackchar) then
                return sText
            end
            local doNow = sText:sub(1,thenStart-2)
            Execute(doNow)
        end

        implThenCommand(thenDoStr)
        PushCommand(sText)
        return "\t"
    end    
    return sText
end


-------------------------------
--  Help Handlers
--
function helpDoFormat()
    Note("Format:   do <count> <command>")
    Note("Example:  do 5 chop")
end

function helpDoDelay()
    Note("Format:   do delay <length of time in seconds>")
    Note("Examples:  do delay 1.5")
end

function helpDoDelayNote()
    Note("Note that a delay in this value is random between the delay and twice the delay.")
    Note("So, for example, a 2 second delay will be between 2-4 seconds. ")
end

-------------------------------
--  Alias Handlers
--
function setThenCommand(rname, rline, rWildcards)
    implThenCommand(rWildcards[1])
end

function implThenCommand(thenStr)

    --NOTE: We have to strip the value for display only.
    Note("Delaying command: ["..stripCommand(thenStr).."]")

    -- Here, we pass the un-stripped version
    then_command = thenStr
end

function clearThenCommand()
    Note("Delayed command cleared.")
    then_command = ""
end


function setDoCommand(rname, rLine, rWildcards)
    implSetDoCommand(rWildcards[1], rWildcards[2])
end

function implSetDoCommand(count,command)

    local count_val = tonumber(count)

    if (count_val == nil) then
        Note("The count must be a valid number")
        helpDoFormat()
        return
    end
    if (count_val < 1) then
        Note("The count must be greater than zero.  How many times do you want to do it?")
        helpDoFormat()
        return
    end

    do_command = command
    do_count = count_val

    --NOTE: We have to strip the value for display only.
    Note("Doing ["..stripCommand(do_command).."] for "..do_count.." times")

    if (config_delay ~= DEFAULT_DELAY) then
        local secstr = "seconds"
        if (config_delay == 1) then secstr = "second" end
        Note("Configured delay: "..config_delay.. " "..secstr)
    end

    do_count = do_count - 1

    -- Do the first one now, without delay.
    executeDoCommand()
end

function clearDoCommand(sendNote)
    do_command = ""
    do_count = -1
    if (sendNote ~= false) then
        Note("Do command cleared.")
    end
end

function clearAll()
    clearDoCommand()
    clearThenCommand()
end

function setDoDelay(rname, rLine, rWildcards)
    local delay_val = tonumber(rWildcards[1])

    if (delay_val == nil or delay_val < 0) then
        Note("Invalid delay value specified.")
        helpDoDelay()
        return
    end
    local send_note = false
    if ((config_delay == DEFAULT_DELAY) or ((math.random()*3) < 1)) then
       send_note = true
    end

    config_delay = delay_val
    SetVariable("dodelay", delay_val)
    Note("Command delay set to "..config_delay)
    if (send_note) then
        helpDoDelayNote()
    end
end

-------------------------------
--  Trigger Handlers
--
function actionCompleted()
    if (do_command ~= nil and do_command ~= "" and do_count > 0) then
        if (do_count == 1) then
            Note("Final iteration of ["..stripCommand(do_command).."]")
        else
            Note("Repeating ["..stripCommand(do_command).."] "..do_count.." more times.")
        end
        do_count = do_count - 1

        DoAfterDelay(DO_CALLER)
        return
    elseif (do_count == 0) then
        Note("Do command complete")
        clearDoCommand(false)
    end
    if (then_command ~= nil and then_command ~= "") then
        DoAfterDelay(THEN_CALLER)
    end
end

-------------------------------
--  Delay ("wait 1.5") Processing
--
function ContinueAfterDelay(delay)
     --this will only happen for configured delays
    if (delay == 0) then
        continueCommand()
        return
    end
    local randDelay = getRandDelay(delay)
    DoAfterSpecial(randDelay, "continueCommand()" ,12)
end

function ExecuteCaller(caller)
    if (caller == THEN_CALLER) then
        executeThenCommand()
    else
        executeDoCommand()
    end
end

--  This function launches the command processing
function DoAfterDelay(caller)
    if (config_delay == 0) then
        ExecuteCaller(caller)
        return
    end
    local randDelay = getRandDelay(config_delay)
    DoAfterSpecial(randDelay, "ExecuteCaller("..caller..")" ,12)
end



-------------------------------
--  Command processing
--
exec_command = ""
function executeDoCommand()
    exec_command = do_command
    if (exec_command ~= nil and exec_command ~= "") then
        executeCommand(exec_command)
    end
end

function executeThenCommand()
    exec_command = then_command
    if (then_command ~= nil and then_command ~= "") then
        then_command = ""
        executeCommand(exec_command)
    end
end

function continueCommand()
    if (exec_command ~= nil and exec_command ~= "") then
        executeCommand(exec_command)
    end
end

function executeCommand(command)

    -- This looks overly complicated, but it allows us to add a "wait N" in the middle of a "then" string
    --      Example, "then get obj;ne;ne;wait 2;give obj mob"
    -- Also, it allows that "wait" delay to be anywhere in the string
    --      Example: "then wait 2.5;chop"
    -- Finally, the "then" commands can be stacked, such as:
    --      Example: "then chop;then bundle all poplar;wait 1;get poplar;chop;then get poplar"

    local stackchar = GetAlphaOption("command_stack_character")

    -- TODO:  Currently, this does not check for ;;then escape characters.
    -- So, typing in do 5 chop;;then bundle poplar... not so much.
    -- To fix this, the entire loop needs changed to a byte-by-byte check to look for semi-colons
    -- ... a true parser.  Doing that in Lua, though, would not be exactly efficient.

    local delayrest = false
    local next_command = ""
    local delayval = ""
    -- Presume the stackchar regex safe...  (99.99% sure it will be a semicolon or pipe)
    for cmd in command:gmatch("[^"..stackchar.."]+") do
        if (delayrest == true) then
            if (next_command ~= "") then next_command = next_command..stackchar end
            next_command = next_command .. cmd
        else

            local sub5 = cmd:sub(1,5)
            if (sub5 == "then ") then
                delayrest = true
                next_command = cmd:sub(6)
            elseif (sub5 == "wait ") then
                local wait_command = cmd:sub(6)
                delayval = cmd:match("[%d\.]+")
                if (delayval ~= nil) then
                    delayrest = true
                else
                    Execute(cmd)
                end
            else
                Execute(cmd)
            end
        end
    end

    -- NOTE: If there is no "next_command", this will clear the command (normal case)
    --    e.g... then chop;then chop;then chop

    if (delayval ~= "" and next_command ~= "") then
        exec_command = next_command

        local delay = tonumber(delayval)
        if (delay >= 1) then
            Note("Delaying "..delay.." seconds.")
        end
        ContinueAfterDelay(delay)
    elseif (next_command ~= "") then
        implThenCommand(next_command)
    end
end


]]>
</script>


</muclient>
